## What's UAF?  

### Use After Free
There exists a dangling ptr that we use the same chunk after free().  
We always can see the example in two function ptr in two structure.  

```C
struct stu  
{  
  long stu_id;  
  name[8];
}
struct hi  
{  
  void (*playwithme)();  
  void (*please)();  
  char ok[8];  
}
```
The following is an important example for dangling ptr.Assume that **p is the ptr of hi** then we free(p).Second, we malloc a same size of stu as hi, they will use the same chunk because reason of **fastbin**. However, the data in hi **won't clean up** by free(), so if we store 0xdeadbeef in stuid, we will hijack the function ptr that *p.playwithme() -> 0xdeadbeef*

### The example Can help you Understand
1. [HITCONPWNTRAINING](https://github.com/shinmao/NCU-Babies-Hacker/blob/master/HITCON-PWN-Training/lab10-UAF.py) Â 
  
    In this example,**pay attention** to the function pointer of void(printnote)() in struct note,when we overwrite it with **magic**, it       means that we hijack the printnote() to magic(), then next time we call print it will become magic! :kissing_closed_eyes:  
```C
struct note  
{  
  void (*printnote)();  
  char *content;
}
struct note *notelist[5];  
//add(magic~~~)
notelist[idx]->printnote(notelist[idx]);
//bomb~~  
```
