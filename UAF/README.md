## What's UAF?  
Two pointer to the same memory, one is structure, another is data buffer, we can exploit the buffer to change or even leak the data in struct.

### Use After Free
There exists a dangling ptr that we use the same chunk after free().  
We always can see the example in two function ptr in two structure.  

```C
struct stu  
{  
  long stu_id;  
  name[8];
}
struct hi  
{  
  void (*playwithme)();  
  void (*please)();  
  char ok[8];  
}
```
The above is an important example for dangling ptr.Assume that **p is the ptr of hi** then we free(p).Second, we malloc a same size of stu as hi, they will use the same chunk because reason of **fastbin**. However, the data in hi **won't clean up** by free(), so if we store 0xdeadbeef in stuid, we will hijack the function ptr that *p.playwithme() -> 0xdeadbeef*  
Therefore, we should change the ptr to NULL after we free() it.

### The example Can help you Understand
1. [HITCON-PWN-TRAINING](https://github.com/shinmao/NCU-Babies-Hacker/blob/master/HITCON-PWN-Training/lab10-UAF.py)  
  
    In this example,**pay attention** to the function pointer of void(printnote)() in struct note,when we overwrite it with **magic**, it       means that we hijack the printnote() to magic(), then next time we call print it will become magic! :kissing_closed_eyes:  
```C
struct note  
{  
  void (*printnote)();  
  char *content;
}
struct note *notelist[5];  
//add(magic~~~)
notelist[idx]->printnote(notelist[idx]);
//bomb~~  
```
2. Source code is in **use-after-free.cpp** on the above.  
   In this example, I will exploit the vtable function in **C++** objects.vtable will store the function address.One more time, think about where is the buffer we can control, then we can use it to overwrite the call function address.  
taste my payload in use-after-free.py  
```C
A *p = new B();
delete p;
```
