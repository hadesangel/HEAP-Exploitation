## Off-By-One (heap based)  
Off by one is a very common mistake we can see from the program, and the exploitation can also used on stack, .bss, heap....and so on. Heap based off-by-one is also most common one popular in CTF. In this guide, I will not focus on how the off-by-one happen. if you are interested in it, you can take a look at my another article in following link.  
[Details of Programmer Mistake](https://rafaelchen.wordpress.com/2017/11/11/off-by-one/#more-1996)

### With heap exploitation
With off-by-one, only one bytes of overflow can cause RCE(remote code execution)!  
<img src="https://github.com/shinmao/WhyNot-HEAP-Exploitation/blob/master/Off-By-One/picture/off-by-one.png" width="607" height="332">  
With the picture, I will introduce two kind of off-by-one attack based on heap.  
#### Something we need to know first...  
In operation system based on 64bits, the memory is aligned with 16 bytes (and aligned with 8 bytes in x86). For example, if you ```malloc(0x108)``` prev_size header of next chunk will overlap with the 8 bytes in the end. Also because of this, the one-byte overflow can overwrite the size header.  

## :fire: Our Goal: Produce overlapping chunks to change the content of other chunks 

### off-by-one overwrite freed or allocated(Extend the chunk)  
Looking at chunks on the left side of the picture, we malloc three chunks, red for off-by-one vulnerability, second for overwriting, and the third one is our target chunk which we want to write into.  
#### Exploit 
When we malloc three chunks, we need to be careful that the size should be ```0x10*n+0x8``` or ```0x10*n-0x8``` with n is integer because we want to overwrite the size header. If we just ```malloc(0x10*n)```, the one-byte overflow will overwrite the prev_size header.  
```C
                --------------------------------------
                | a a a a a a a a  |  a a a a a a a a |  <----- whole of 16 bytes
                 --------------------------------------
 prev_si head > | a a a a a a a a  |         overflow |   <----- size header  
                --------------------------------------
```  
Second, we overwrite one byte of size header with ```second chunk size + third chunk size```, also be sure that inuse bit of second chunk is 1.  
In the end, if the second chunk is allocated, you need to free the second chunk first, and don't need to do nothing if the chunk is already freed. When you malloc(second_size+third_size), you can get write accress to the third chunk!

### off-by-one overwrite null byte(Shrink the chunk)  
Compared with the above one, this time we will overwrite the size with null byte. Our target is to get access to **b2** chunk. 
#### Exploit  
Before we overwrite the size header of second chunk, we should free the second chunk first because of the check ```size(chunk) != prev_size(next_chunk) ```. After we free it, we can bypass the check to overwrite the size we want.  
Second, we would malloc two smaller chunk in section of b chunk: b1, b2, and ptr of b1 is same as b. Therefore, ```free(b1) = free(b)```. So, if we free(b1) and ```free(c)```, c will imagine that the b chunk has been freed and consolidate with it.  Next time we malloc a size of b and c then we can get the whole chunk to write! Â 
```C  
    first          second           third
  A-----------B-------------------C---------  
  |          |     |      |       |        |
  |          |     b1     b2      |        |  
  |-----------------------------------------  
  |          |     |      |       |        |    
  |-----------------------------------------
```  
  
**Use GDB to trace the code of exploit.c file and you can get it done!** :+1::+1:

### How about review the consolidate  
After we free the chunk which does not come from mmap()...  
Here, the **next** chunk means in consecutive memory!  
 ```
 if (next chunk is top chunk && previous chunk is freed) : 
     consolidate into top chunk...  
 elif (next chunk isn't top chunk) : 
     if (previous chunk is freed)  
          unlink the prev chunk and consolidate  
     elif (next chunk is freed or inuse) :
          unlink the free chunk and get into the unsorted bin  
 else :  
     Go away.....
 ```
