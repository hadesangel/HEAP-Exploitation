## I will learn exploitation of heap and introduce it with CTF example :smirk:  
  
### Vulnerability  
Most of heap exploitation are based on the careless machinism of ptmalloc.  
1. inuse(): only use the prev_use flag of next chunk to check whether the current chunk is allocated or not.  
2. prev_chunk(): only use prev_size to get the header of previous chunk.  
3. next_chunk(): only use **header + size** of current chunk to get the next header.  
4. chunksize: only check the size of current chunk.  
  
### Exploitation  
1. **UAF** [Enjoy the dir of UAF]  
2. **Unsafe unlink**
3. **Fastbin Corruption** [Enjoy the dir of fastbinattack]  
4. **House of Force** [Enjoy the dir of House Of Force]
5. **Unsorted bin Attack** [Enjoy the dir of Unsorted-bin-attack] 
6. **Off By One** [Enjoy the dir of Off-By-One]  
  
### Glibc Heap Structure Overview  
Following source code is malloc.c
```C
struct malloc_chunk{
  INTERNAL_SIZE_T prev_size;   /* only previous one is free */
  INTERNAL_SIZE_T size;        /* size of chunk include header */
  
  struct malloc_chunk* fd;     /* only link if freed */
  struct malloc_chunk* bk;     
  /* only in larger one, next chunk */
  struct malloc_chunk* fd_nextsize;
  struct malloc_chunk* bk_nextsize;
```  
* There is flag in size header, the most import one is prev-inuse() used to check whether previous chunk is free or not.  
* When chunk is free, it can be merged into previous one or following one, and that is also prev-size header work for.  
* However, fastbin chunks don't follow the rules above, for efficiency!  
* Heap allocation can be seen as **first fit** algorithm, which means that allocation will happen on the last freed chunk if big enough.




