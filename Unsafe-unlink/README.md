## What's Unsafe-unlink?  
When the program has the vulnerability of heap overflow, we can exploit unlink mechanism to write anywhere!  
  
### Unlink  
When we free a chunk, it will trigger unlink().  
```C
unlink(P, BK, FD){
  FD = P->fd ;  
  BK = p->bk ;  
  FD->bk = BK ;  
  BK->fd = FD ;  
}
```  
The above is the source code of unlink() function. It means that terminate the link between chunk and chunk.  
FD, BK, and P are all chunks, and linked by fd(foward), bk(backward) pointer, so the pointer are just as +0x10, +0x18.  
So, if we want to GOT hijacking, we can just overwrite FD with GOT-Adr - 0x18 and overwrite BK with shellcode Adr.  
```C
unlink(){
  FD = GOT-Adr - 0x18  
  BK = shellcode-Adr  
  GOT-Adr - 0x18 + 0x18 = shellcode-Adr       /*GOT hijacking!!*/  
  shellcode-Adr + 0x10 = GOT-Adr - 0x18
}
```  
  
### Challenges and Solutions  
However, challenges are always fucking on our roads...  
1.Corrupted double linked list  
```C
P->bk->fd == P  
P->fd->bk == P
```  
Here is also an amazing skill to bypass the detection XD. We just need to overwrite FD with (target-0x18) and BK with (target-0x10) and can success!  
```C
unlink(){
  FD = *target - 0x18 ; 
  BK = *target - 0x10 ; 
  /*Now, let's look at the detection*/  
  *target - 0x10 + 0x10 = *target        /*Good! You pass!*/  
  *target - 0x18 + 0x18 = *target        /*Good! You have passed all detections!*/
}
```  
Next time we malloc(), the chunk will be placed at (target-0x18).  
2.Corrupted size vs prevsize  
To prevent from the size being modified...  
```C
chunksize(P) == next_chunk(P)->prev_size  
/*new in glibc 2.26!*/
```  
Therefore, we also need to forge the next chunk size when overflowing.  
**Usually, target will be a data pointer or function pointer, then you can overwrite the ptr to hijack the control flow.**  
  
### Payload  
A picture a day can help you exploit anyway :smile:  
<img src="https://github.com/shinmao/WhyNot-HEAP-Exploitation/blob/master/Unsafe-unlink/picture/unsafe-unlink.png" width="252" height="495">



